--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,3 +1,3 @@
 bin_PROGRAMS = chinadns
 
-chinadns_SOURCES = chinadns.c local_ns_parser.c local_ns_parser.h
+chinadns_SOURCES = chinadns.c
--- a/src/chinadns.c
+++ b/src/chinadns.c
@@ -31,8 +31,6 @@
 #include <sys/time.h>
 #include <sys/param.h>
 
-#include "local_ns_parser.h"
-
 #include "config.h"
 
 typedef struct {
@@ -573,8 +571,8 @@ static void dns_handle_local() {
   ns_msg msg;
   len = recvfrom(local_sock, global_buf, BUF_SIZE, 0, src_addr, &src_addrlen);
   if (len > 0) {
-    if (local_ns_initparse((const u_char *)global_buf, len, &msg) < 0) {
-      ERR("local_ns_initparse");
+    if (ns_initparse((const u_char *)global_buf, len, &msg) < 0) {
+      ERR("ns_initparse");
       free(src_addr);
       return;
     }
@@ -661,8 +659,8 @@ static void dns_handle_remote() {
   ns_msg msg;
   len = recvfrom(remote_sock, global_buf, BUF_SIZE, 0, src_addr, &src_len);
   if (len > 0) {
-    if (local_ns_initparse((const u_char *)global_buf, len, &msg) < 0) {
-      ERR("local_ns_initparse");
+    if (ns_initparse((const u_char *)global_buf, len, &msg) < 0) {
+      ERR("ns_initparse");
       free(src_addr);
       return;
     }
@@ -733,8 +731,8 @@ static const char *hostname_from_questio
   if (rrmax == 0)
     return NULL;
   for (rrnum = 0; rrnum < rrmax; rrnum++) {
-    if (local_ns_parserr(&msg, ns_s_qd, rrnum, &rr)) {
-      ERR("local_ns_parserr");
+    if (ns_parserr(&msg, ns_s_qd, rrnum, &rr)) {
+      ERR("ns_parserr");
       return NULL;
     }
     result = ns_rr_name(rr);
@@ -773,8 +771,8 @@ static int should_filter_query(ns_msg ms
     return -1;
   }
   for (rrnum = 0; rrnum < rrmax; rrnum++) {
-    if (local_ns_parserr(&msg, ns_s_an, rrnum, &rr)) {
-      ERR("local_ns_parserr");
+    if (ns_parserr(&msg, ns_s_an, rrnum, &rr)) {
+      ERR("ns_parserr");
       return 0;
     }
     u_int type;
--- a/src/local_ns_parser.c
+++ b/src/local_ns_parser.c
@@ -1,248 +0,0 @@
-#include <errno.h>
-#include <resolv.h>
-#include "local_ns_parser.h"
-
-static void local_ns_setsection(ns_msg *msg, ns_sect sect);
-static int local_ns_skiprr(const unsigned char *ptr, const unsigned char *eom, ns_sect section, int count);
-static int local_ns_dn_skipname(const unsigned char *ptr, const unsigned char *eom);
-static int local_ns_name_skip(const unsigned char **ptrptr, const unsigned char *eom);
-static int local_ns_labellen(const unsigned char *lp);
-#define LOCAL_NS_TYPE_ELT 0x40 /*%< EDNS0 extended label type */
-#define LOCAL_DNS_LABELTYPE_BITSTRING 0x41
-#ifdef __UCLIBC__
-#define LOCAL_NS_MSG_PTR _ptr
-#else
-#define LOCAL_NS_MSG_PTR _msg_ptr
-#endif
-
-int local_ns_initparse(const unsigned char *msg, int msglen, ns_msg *handle)
-{
-	const unsigned char *eom = msg + msglen;
-	int i;
-
-	handle->_msg = msg;
-	handle->_eom = eom;
-	if (msg + NS_INT16SZ > eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-
-	NS_GET16(handle->_id, msg);
-	if (msg + NS_INT16SZ > eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-
-	NS_GET16(handle->_flags, msg);
-	for (i = 0; i < ns_s_max; i++) {
-		if (msg + NS_INT16SZ > eom) {
-			errno = EMSGSIZE;
-			return -1;
-		}
-
-		NS_GET16(handle->_counts[i], msg);
-	}
-	for (i = 0; i < ns_s_max; i++)
-		if (handle->_counts[i] == 0)
-			handle->_sections[i] = NULL;
-		else {
-			int b = local_ns_skiprr(msg, eom, (ns_sect)i,
-					handle->_counts[i]);
-
-			if (b < 0)
-				return -1;
-			handle->_sections[i] = msg;
-			msg += b;
-		}
-
-	if (msg != eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-
-	local_ns_setsection(handle, ns_s_max);
-	return 0;
-}
-int local_ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr)
-{
-	int b;
-	int tmp;
-
-	/* Make section right. */
-	tmp = section;
-	if (tmp < 0 || section >= ns_s_max) {
-		errno = ENODEV;
-		return -1;
-	}
-
-	if (section != handle->_sect)
-		local_ns_setsection(handle, section);
-
-	/* Make rrnum right. */
-	if (rrnum == -1)
-		rrnum = handle->_rrnum;
-	if (rrnum < 0 || rrnum >= handle->_counts[(int)section]) {
-		errno = ENODEV;
-		return -1;
-	}
-	if (rrnum < handle->_rrnum)
-		local_ns_setsection(handle, section);
-	if (rrnum > handle->_rrnum) {
-		b = local_ns_skiprr(handle->LOCAL_NS_MSG_PTR, handle->_eom, section,
-				rrnum - handle->_rrnum);
-
-		if (b < 0)
-			return (-1);
-		handle->LOCAL_NS_MSG_PTR += b;
-		handle->_rrnum = rrnum;
-	}
-
-	/* Do the parse. */
-	b = dn_expand(handle->_msg, handle->_eom,
-			handle->LOCAL_NS_MSG_PTR, rr->name, NS_MAXDNAME);
-	if (b < 0)
-		return (-1);
-	handle->LOCAL_NS_MSG_PTR += b;
-	if (handle->LOCAL_NS_MSG_PTR + NS_INT16SZ + NS_INT16SZ > handle->_eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-	NS_GET16(rr->type, handle->LOCAL_NS_MSG_PTR);
-	NS_GET16(rr->rr_class, handle->LOCAL_NS_MSG_PTR);
-	if (section == ns_s_qd) {
-		rr->ttl = 0;
-		rr->rdlength = 0;
-		rr->rdata = NULL;
-	} else {
-		if (handle->LOCAL_NS_MSG_PTR + NS_INT32SZ + NS_INT16SZ > handle->_eom) {
-			errno = EMSGSIZE;
-			return -1;
-		}
-		NS_GET32(rr->ttl, handle->LOCAL_NS_MSG_PTR);
-		NS_GET16(rr->rdlength, handle->LOCAL_NS_MSG_PTR);
-		if (handle->LOCAL_NS_MSG_PTR + rr->rdlength > handle->_eom) {
-			errno = EMSGSIZE;
-			return -1;
-		}
-		rr->rdata = handle->LOCAL_NS_MSG_PTR;
-		handle->LOCAL_NS_MSG_PTR += rr->rdlength;
-	}
-	if (++handle->_rrnum > handle->_counts[(int)section])
-		local_ns_setsection(handle, (ns_sect)((int)section + 1));
-
-	return 0;
-}
-static void local_ns_setsection(ns_msg *msg, ns_sect sect)
-{
-	msg->_sect = sect;
-	if (sect == ns_s_max) {
-		msg->_rrnum = -1;
-		msg->LOCAL_NS_MSG_PTR = NULL;
-	} else {
-		msg->_rrnum = 0;
-		msg->LOCAL_NS_MSG_PTR = msg->_sections[(int)sect];
-	}
-}
-static int local_ns_skiprr(const unsigned char *ptr, const unsigned char *eom, ns_sect section, int count)
-{
-	const unsigned char *optr = ptr;
-
-	for (; count > 0; count--) {
-		int b, rdlength;
-
-		b = local_ns_dn_skipname(ptr, eom);
-		if (b < 0) {
-			errno = EMSGSIZE;
-			return -1;
-		}
-		ptr += b/*Name*/ + NS_INT16SZ/*Type*/ + NS_INT16SZ/*Class*/;
-		if (section != ns_s_qd) {
-			if (ptr + NS_INT32SZ + NS_INT16SZ > eom) {
-				errno = EMSGSIZE;
-				return -1;
-			}
-
-			ptr += NS_INT32SZ/*TTL*/;
-			NS_GET16(rdlength, ptr);
-			ptr += rdlength/*RData*/;
-		}
-	}
-
-	if (ptr > eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-
-	return ptr - optr;
-}
-static int local_ns_dn_skipname(const unsigned char *ptr, const unsigned char *eom)
-{
-	const unsigned char *saveptr = ptr;
-
-	if (local_ns_name_skip(&ptr, eom) == -1)
-		return -1;
-
-	return ptr - saveptr;
-}
-static int local_ns_name_skip(const unsigned char **ptrptr, const unsigned char *eom)
-{
-	const unsigned char *cp;
-	unsigned int n;
-	int l;
-
-	cp = *ptrptr;
-	while (cp < eom && (n = *cp++) != 0) {
-		/* Check for indirection. */
-		switch (n & NS_CMPRSFLGS) {
-			case 0: /*%< normal case, n == len */
-				cp += n;
-				continue;
-			case LOCAL_NS_TYPE_ELT: /*%< EDNS0 extended label */
-				if ((l = local_ns_labellen(cp - 1)) < 0) {
-					errno = EMSGSIZE; /*%< XXX */
-					return -1;
-				}
-				cp += l;
-				continue;
-			case NS_CMPRSFLGS:      /*%< indirection */
-				cp++;
-				break;
-			default: /*%< illegal type */
-				errno = EMSGSIZE;
-				return -1;
-		}
-
-		break;
-	}
-
-	if (cp > eom) {
-		errno = EMSGSIZE;
-		return -1;
-	}
-
-	*ptrptr = cp;
-
-	return 0;
-}
-static int local_ns_labellen(const unsigned char *lp)
-{
-	int bitlen;
-	unsigned char l = *lp;
-
-	if ((l & NS_CMPRSFLGS) == NS_CMPRSFLGS) {
-		/* should be avoided by the caller */
-		return -1;
-	}
-
-	if ((l & NS_CMPRSFLGS) == LOCAL_NS_TYPE_ELT) {
-		if (l == LOCAL_DNS_LABELTYPE_BITSTRING) {
-			if ((bitlen = *(lp + 1)) == 0)
-				bitlen = 256;
-			return ((bitlen + 7 ) / 8 + 1);
-		}
-
-		return -1;    /*%< unknwon ELT */
-	}
-
-	return l;
-}
--- a/src/local_ns_parser.h
+++ b/src/local_ns_parser.h
@@ -1,7 +0,0 @@
-#ifndef LOCAL_NS_PARSER_H
-#define LOCAL_NS_PARSER_H
-
-int local_ns_initparse(const unsigned char *msg, int msglen, ns_msg *handle);
-int local_ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr);
-
-#endif
